
"""
Created on Tue Aug 20 12:55:42 2024

@author: Carles Roch i Carceller
"""

import numpy as np
import mosek
import cvxpy as cp
from cvxpy import *

#-----------------------------------------------------------------------------#
#-----------------------------------------------------------------------------#
#                                  FUNCTIONS                                  #
#-----------------------------------------------------------------------------#
#-----------------------------------------------------------------------------#

def deltaF(x,n):
    if x == n:
        return 1.0
    else:
        return 0.0

def M_ones(matrix,element,eps):
    
    """
    Identifies elements eps-equivalent to a chosen value and
    returns another matrix with ones in those slots
    """
    
    output = np.zeros((len(matrix),len(matrix)))
    
    for i in range(len(matrix)):
        for j in range(len(matrix)):
            if i >= j:
                if np.abs(matrix[i][j]-element) <= eps:
                    output[i][j] = 1
                    output[j][i] = 1 # For symmetric matrices
    
    return output

def MomentMatrix_construction(d):
    
    """
    Build the momnent matrix for the SDP relaxation
    """
    
    [nX0,nX1,nY0,nY1] = [d,d,d,d]
    [nZ,nC] = [d+1,d]
        
    id_els = list(range(7))
    
    [ dim, one, zero, Delta_r, d_Delta_s,  Delta_r_over_d, one_over_d] = id_els
    cc = 7
    id_probs = []
    for c in range(nC):
        id_probs += [[]]
        for z in range(nZ):
            id_probs[c] += [cc]
            cc += 1
            
    id_els += [id_probs[c][z] for c in range(nC) for z in range(nZ)]

    T_ss = np.zeros((nY0 * nY1, nY0 * nY1))
    for i in range(nY0 * nY1):
        for j in range(nY0 * nY1):
            T_ss[i, j] = dim if i == j else d_Delta_s
    
    def T_sMr_entry(i, j):
        # Reverse i into (y0, y1)
        y1, y0 = divmod(i, nY0)
        
        # Reverse j into (c, z, x0, x1)
        x1, remainder = divmod(j, nC * nZ * nX0)
        x0, remainder = divmod(remainder, nC * nZ)
        z, c = divmod(remainder, nC)
    
        if d > 2:
            if z < d:
                w = (x1 + y1 - 2.0 * z * (x0 - y0)) % d
            else:
                w = (x0 - y0) % d
        else:
            if z == 0:
                w = (x0 + y0) % d
            elif z == 1:
                w = (x1 + y1) % d
            elif z == 2:
                w = (x0 + y0 + x1 + y1) % d
        
        return id_probs[int(np.mod(c-w,d))][z]
        #return Rd if c == w else not_Rd
    
    T_sMr = np.zeros((nY0 * nY1, nC * nZ * nX0 * nX1))
    for i in range(nY0 * nY1):
        for j in range(nC * nZ * nX0 * nX1):
            T_sMr[i, j] = T_sMr_entry(i, j)

    def T_MrMr_entry(i, j):
        # Reverse i into (c, z, x0, x1)
        x1, remainder = divmod(i, nC * nZ * nX0)
        x0, remainder = divmod(remainder, nC * nZ)
        z, c = divmod(remainder, nC)
        
        # Reverse j into (cc, zz, xx0, xx1)
        xx1, remainder = divmod(j, nC * nZ * nX0)
        xx0, remainder = divmod(remainder, nC * nZ)
        zz, cc = divmod(remainder, nC)
    
        if z == zz:
            if c == cc:
                if x0 == xx0 and x1 == xx1:
                    return one
                else:
                    return Delta_r
            else:
                return zero
        else:
            if x0 == xx0 and x1 == xx1:
                return one_over_d
            else:
                return Delta_r_over_d
    
    T_MrMr = np.zeros((nC * nZ * nX0 * nX1, nC * nZ * nX0 * nX1))
    for i in range(nC * nZ * nX0 * nX1):
        for j in range(nC * nZ * nX0 * nX1):
            T_MrMr[i, j] = T_MrMr_entry(i, j)
    
    # Combine all matrices into the moment matrix
    MomMat = np.block([
        [T_ss   , T_sMr ],
        [T_sMr.T, T_MrMr]
    ])
    
    del T_ss, T_sMr, T_MrMr
    
    return MomMat, id_els

def BD_MomMat(MomMat,id_els,d):
    
    """
    Block-diagonalize a given moment matrix  "MomMat" with identical elements 
    listed in "id_els"
    """
    
    threshold = 1e-3
    n = len(MomMat[0])	
    m = len(id_els)
    
    A = []
    for i in range(len(id_els)):
        A += [ M_ones(MomMat,id_els[i],1e-6) ]

    # B is a random self-adjoint matrix generated by matrices from A (and their conjugate transposes)
    B = np.zeros((n,n))
    for p in range(m):
   		B = B + np.random.normal()*(A[p]+A[p].transpose())

    # find the eigenvalues and eigenvectors of B
    D, V = np.linalg.eigh(B)

    # C is a matrix used to sort the column vectors of V (i.e., the base vectors)
    # such that the base vectors corresponding to the same common block are next to each other
    C = np.zeros((n,n))
    for p in range(m):
        C = C + np.random.normal()*(A[p]+A[p].transpose())
    C = V.transpose()@C@V

    # arrays used to track which base vectors have been sorted
    remaining_basis = list(range(n))
    sorted_basis = []

    ListBlocks = []	# initialize the array that lists the size of each common block

    # the sorting process: find C_ij's that are nonzero and group the base vectors v_i and v_j together
    while len(remaining_basis) > 0:
        current_block = [remaining_basis[0]]
        current_block_size = 1
        if len(remaining_basis) > 1:
            for idx in remaining_basis[1:]:
                if np.abs(C[remaining_basis[0],idx]) > threshold:
                    current_block.append(idx)
                    current_block_size = current_block_size + 1

        for idx in current_block:
            sorted_basis.append(idx)
            remaining_basis.remove(idx)

		# do the following in case there are zero entries inside the block
        current_block_extra = []
        if len(remaining_basis) > 0:
            for idx in remaining_basis:
                for ind in current_block:
                    if np.abs(C[ind,idx]) > threshold:
                        current_block_extra.append(idx)
                        current_block_size = current_block_size + 1
                        break

        for idx in current_block_extra:
            sorted_basis.append(idx)
            remaining_basis.remove(idx)

        ListBlocks.append(current_block_size)
    
    # the sorted base vectors give the final orthogonal/unitary transformation matrix that performs SBD on A
    Trans = V[:,sorted_basis]

    P = []
    for i in range(len(id_els)):
        P += [ Trans.T @ A[i] @ Trans ]
            
    return Trans, ListBlocks, P

#-----------------------------------------------------------------------------#
#-----------------------------------------------------------------------------#
#                                  MAIN CODE                                  #
#-----------------------------------------------------------------------------#
#-----------------------------------------------------------------------------#

d = 3 # Dimension

[nX0,nX1,nY0,nY1] = [d,d,d,d] # Number of settings for state preparations
[nZ,nC] = [d+1,d] # Number of measurement settings and outcomes

# Build the moment matrix 
# (already taking into account the variable reduction by symmetrization)
print('Building moment matrix...')
MomMat, id_els = MomentMatrix_construction(d)
print(id_els)
# Block diagonlization of the SDP
print('Block diagonalizing...')
Trans, list_blocks, P = BD_MomMat(MomMat,id_els,d)
# Trans = np.identity(len(MomMat))
# list_blocks = [len(MomMat)]
# Write the SDP in the new block-diagonalized form

# List of values of the identifiable elements (id_els)
#values = [ d, 1.0, 0.0, dr, d*ds, dr/d, 1.0/d]
# indexes: 0   1    2   3     4    5      6
cc = 7
id_probs = []
for c in range(nC):
    id_probs += [[]]
    for z in range(nZ):
        id_probs[c] += [cc]
        cc += 1

# List all the blocks
Q = []
iniB = 0
nBlocks = 0
for l in range(len(list_blocks)):
    finB = iniB + list_blocks[l]
    if finB - iniB > 0.0:
        nBlocks += 1
        Q += [ [ P[s][iniB:finB,iniB:finB] for s in range(len(id_els)) ] ]
    iniB += list_blocks[l]

# Define Dual variables
Y = {}
for l in range(nBlocks):
    Y[l] = cp.Variable(np.shape(Q[l][0]),PSD=True)
v = cp.Variable(nZ)

# Dual object function
dual_obj = sum([ cp.trace( Y[l] @ (d*Q[l][0] + Q[l][1] + (1.0/d)*Q[l][6]) ) for l in range(nBlocks) ]) + sum([v[z] for z in range(nZ)])

# List the SDP constraints
ct = []
ct += [ sum([ cp.trace( Y[l] @ (Q[l][3] + (1.0/d)*Q[l][5]) ) for l in range(nBlocks) ]) == 0.0 ]
ct += [ sum([ cp.trace( Y[l] @ Q[l][4] ) for l in range(nBlocks) ]) == 0.0 ]
ct += [ deltaF(c,0)/(d+1) + sum([ cp.trace( Y[l] @ Q[l][id_probs[c][z]] ) for l in range(nBlocks) ]) - v[z] == 0.0 for z in range(nZ) for c in range(nC) ]
ct += [ Y[l] == Y[l].H for l in range(nBlocks) ] 

# Build and solve the SDP using CVXPY and MOSEK
obj = cp.Minimize(dual_obj)
prob = cp.Problem(obj,ct)

try:
    mosek_params = {
            "MSK_DPAR_INTPNT_CO_TOL_REL_GAP": 1e-1
        }
    prob.solve(solver='MOSEK',verbose=True, mosek_params=mosek_params)

except SolverError:
    something = 10

# Present the results 
print('RESULT FOR DIMENSION',d,'IS:',dual_obj.value)
print('CONJECTURE SAYS:',2.0/(1.0+d))

